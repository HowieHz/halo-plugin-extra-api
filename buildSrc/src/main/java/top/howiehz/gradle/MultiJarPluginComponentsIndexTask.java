package top.howiehz.gradle;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;
import org.gradle.api.DefaultTask;
import org.gradle.api.file.ConfigurableFileCollection;
import org.gradle.api.file.RegularFileProperty;
import org.gradle.api.provider.ListProperty;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.InputFiles;
import org.gradle.api.tasks.Optional;
import org.gradle.api.tasks.OutputFile;
import org.gradle.api.tasks.TaskAction;
import org.gradle.work.DisableCachingByDefault;
import org.objectweb.asm.ClassReader;
import top.howiehz.gradle.utils.AsmConst;
import top.howiehz.gradle.utils.Assert;

/**
 * 支持多个 JAR 任务的插件组件索引生成任务
 * 解决 Halo 官方插件开发工具硬编码 "jar" 任务的限制
 */
@Slf4j
@DisableCachingByDefault(because = "Not worth caching")
public class MultiJarPluginComponentsIndexTask extends DefaultTask {

    /**
     * The package separator character: {@code '.'}.
     */
    private static final char PACKAGE_SEPARATOR = '.';

    /**
     * The path separator character: {@code '/'}.
     */
    private static final char PATH_SEPARATOR = '/';

    private static final String CLASS_SUFFIX = ".class";

    @InputFiles
    ConfigurableFileCollection classesDirs = getProject().getObjects().fileCollection();

    @Input
    Property<String> jarTaskName = getProject().getObjects().property(String.class);

    @Input
    @Optional
    ListProperty<String> excludePackages = getProject().getObjects().listProperty(String.class);

    @OutputFile
    RegularFileProperty outputFile = getProject().getObjects().fileProperty();

    @TaskAction
    public void generate() throws IOException {
        String taskName = jarTaskName.get();
        log.info("Generating plugin components index file for jar task: {}", taskName);

        Set<String> componentsIdxFileLines = new LinkedHashSet<>();
        componentsIdxFileLines.add("# Generated by Halo for " + taskName);
        
        // 获取要排除的包列表
        List<String> excludes = excludePackages.getOrElse(List.of());
        if (!excludes.isEmpty()) {
            log.info("Excluding packages: {}", excludes);
        }
        
        int componentCount = 0;
        int excludedCount = 0;
        for (File file : classesDirs.getAsFileTree()) {
            if (!file.getName().endsWith(CLASS_SUFFIX)) {
                continue;
            }

            try {
                ClassReader classReader = new ClassReader(new FileInputStream(file));
                FilterComponentClassVisitor filterComponentClassVisitor =
                    new FilterComponentClassVisitor(AsmConst.ASM_VERSION);
                classReader.accept(filterComponentClassVisitor, ClassReader.SKIP_DEBUG);

                if (filterComponentClassVisitor.isComponentClass()) {
                    String className =
                        convertResourcePathToClassName(filterComponentClassVisitor.getName());
                    
                    // 检查是否应该排除此类
                    boolean shouldExclude = false;
                    for (String excludePackage : excludes) {
                        if (className.startsWith(excludePackage)) {
                            shouldExclude = true;
                            excludedCount++;
                            log.debug("Excluded component class: {}", className);
                            break;
                        }
                    }
                    
                    if (!shouldExclude) {
                        componentsIdxFileLines.add(className);
                        componentCount++;
                        log.debug("Found component class: {}", className);
                    }
                }
            } catch (Exception e) {
                log.warn("Failed to process class file: {}", file.getPath(), e);
            }
        }

        // 确保输出目录存在
        File outputPath = outputFile.get().getAsFile();
        if (!outputPath.getParentFile().exists()) {
            outputPath.getParentFile().mkdirs();
        }

        // 写入组件索引文件
        Files.write(outputPath.toPath(), componentsIdxFileLines, StandardCharsets.UTF_8);
        
        log.info("Generated plugin components index with {} components ({} excluded) for jar task: {}", 
            componentCount, excludedCount, taskName);
        log.info("Component index file: {}", outputPath.getAbsolutePath());
    }

    public ConfigurableFileCollection getClassesDirs() {
        return classesDirs;
    }

    public Property<String> getJarTaskName() {
        return jarTaskName;
    }

    public ListProperty<String> getExcludePackages() {
        return excludePackages;
    }

    public RegularFileProperty getOutputFile() {
        return outputFile;
    }

    /**
     * Convert a "/"-based resource path to a "."-based fully qualified class name.
     *
     * @param resourcePath the resource path pointing to a class
     * @return the corresponding fully qualified class name
     */
    public static String convertResourcePathToClassName(String resourcePath) {
        Assert.notNull(resourcePath, "Resource path must not be null");
        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);
    }
}
